<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sahil Kharb</title>
    <description>My conversations with neural networks and design patterns.</description>
    <link>http://phoenixx.me/</link>
    <atom:link href="http://phoenixx.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 16 Nov 2015 13:36:05 +0530</pubDate>
    <lastBuildDate>Mon, 16 Nov 2015 13:36:05 +0530</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>Architecture Patterns : Which and why ?</title>
        <description>&lt;blockquote&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Carefully designed structure of something is called architecture.  &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;In software industry this word is often used but rarely followed at first place.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Often all developers start coding their project without a clear picture of the architecture of their application and the reason for not having it is “this is just beginning , we will formalise it at a later stage.” . Eventually it leads to a standard n-tier architecture in which implicitly multiple layers are created to separate modules into packages.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;This will make source code :-&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ol1&quot;&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;unorganised&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;highly coupled (spaghetti code)&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;prone to break down&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;hard to maintain&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;This list is never ending. And it would become just another&lt;strong&gt; “big ball of mud”&lt;/strong&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;The bad architecture will lead to “&lt;a href=&quot;http://batman.wikia.com/wiki/The_Pit&quot; target=&quot;_blank&quot;&gt;The Pit&lt;/a&gt;”. For such poorly architected apps in order to understand the architectural characteristics one need to know the inner working of each component .&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt; The basic questions like &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;will it scale?&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;what are the performance characteristics ?&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;what are the deployment characteristics?&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;how much responsive is to the change?&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;All such questions will be very hard to answer if architecture of your app is not planned properly.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;With a planned architecture one can define the basic working and behaviour of the application. And there are numerous architecture patterns which can be adopted depending on your requirements. For example, some architecture pattern will naturally lend themselves toward highly scalable apps while some other lend themselves to highly agile. Thus knowing strengths and weakness of each architecture pattern is necessary in order to choose for your business. I will be writing on following architecture patterns in coming days:-&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol1&quot;&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://bitfurry.wordpress.com/2015/10/28/understanding-layered-architecture-scrupulously/&quot; target=&quot;_blank&quot;&gt;Layered architecture&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Event-driven_architecture&quot; target=&quot;_blank&quot;&gt;Event-driven architecture&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;http://viralpatel.net/blogs/microkernel-architecture-pattern-apply-software-systems/&quot; target=&quot;_blank&quot;&gt;Microkernel architecture&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li7&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Space-based_architecture&quot; target=&quot;_blank&quot;&gt;Space-based architecture&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Stay tuned.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Credits :- Software architecture patterns by Mark Richards.&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Nov 2015 00:00:00 +0530</pubDate>
        <link>http://phoenixx.me/2015/11/13/architecture-patterns-which-and-why.html</link>
        <guid isPermaLink="true">http://phoenixx.me/2015/11/13/architecture-patterns-which-and-why.html</guid>
        
        
      </item>
    
      <item>
        <title>Prototyping versus Tracer Bullets</title>
        <description>&lt;p&gt;Often developers have this misconception that tracer code concept is a one kind of prototyping in disguise. But they are quite different.&lt;/p&gt;

&lt;p&gt;The sole purpose of each of these concepts differentiate them.&lt;/p&gt;

&lt;p&gt;Prototyping is done with an aim to explore by focussing on specific feature or aspect of the project. In true spirit of prototyping, it should be thrown away after learning lessons from it. And recode entire thing from scratch applying all lessons learnt from the prototype.&lt;/p&gt;

&lt;p&gt;Contrary to this, tracer code addresses a different problem. Tracer code is lean and can disguise as a prototype but it is always complete and not disposable. In this scenario we always have a skeleton of entire system over which developers will keep on hanging new code and features. Tracer code always has a tendency for evolution but prototype are created to serve one purpose and should not be modified to make them production ready.&lt;/p&gt;

&lt;p&gt;Think of prototyping as the training process that takes place before a single tracer bullet is fired.&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Nov 2015 00:00:00 +0530</pubDate>
        <link>http://phoenixx.me/2015/11/11/prototyping-versus-tracer-bullets.html</link>
        <guid isPermaLink="true">http://phoenixx.me/2015/11/11/prototyping-versus-tracer-bullets.html</guid>
        
        
      </item>
    
      <item>
        <title>Don&#39;t repeat yourself</title>
        <description>&lt;blockquote&gt;&quot;Every piece of knowledge must have a single, unambiguous , authoritative representation within a system.&quot;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We all are aware the above stated famous DRY principle, yet we keep on making mistakes, keep on repeating ourselves. In this blog I will be writing about the why duplication happens and what can be done to avoid it. Most of the time you will find that duplication happens due to following reasons :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Developers feels that there is no choice and they are forced to do duplication in other words duplication is &lt;strong&gt;Imposed&lt;/strong&gt; on them.&lt;/li&gt;
&lt;li&gt;Duplication sometimes comes as a result of bad design and developer might not be aware about it i.e. &lt;strong&gt;Inadvertent Duplication&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Imposed Duplication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In every developer&#39;s life there comes a situation when you think that there is no way around but you have to duplicate for your requirements. But by sticking to some of the following techniques one can avoid it.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Avoid comments&lt;/strong&gt;, this may sound opposite to what you have been doing so long, but this is a fact that we are taught that code should have a lots of comments, but unfortunately nobody has told us why code needs comments , only a bad code requires them. Comments become out of date sooner than code, and untrustworthy comments are worse than no comments.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Always write documentation and then write code.&lt;/strong&gt; If something changes append documentation first then change the code. Both always contain representation of same knowledge. And documentation can be used for writing tests or something else thus can be used to save a lot of time.&lt;/li&gt;
&lt;li&gt;Under pressure we tends to take shortcut, avoid standard protocols and become &lt;strong&gt;Impatient&lt;/strong&gt; which will eventually lead to duplication.&lt;/li&gt;
&lt;li&gt;When multiple people work on a project then entire set of functionality inadvertently duplicated and such duplication can go undetected for very long period of time, which makes them hardest of all, this is called &lt;strong&gt;Interdeveloper Duplication&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Inadvertent Duplication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This type of duplication usually happens due to bad design at first place. Scenarios like a multiple classes having same attributes i.e &lt;strong&gt;unnormalised data &lt;/strong&gt;is created and when there is any update requirement for such attributes then one has to make sure that update happens in all classes. This kind of situations can be simply avoided by creating a good design which will eventually never create any unnormalised data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Impatient Duplication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In almost every project , there comes a situation when due to time pressures ,most of us tend to take shortcuts , like just copy from somewhere and modify according to requirements, or just hardcode values etc. All these things attracts even best of us, only advice for such situations is a discipline and willingness to spend time up front to save pain later. When you are tempted to make such mistake always remember &quot;&lt;strong&gt;Shortcuts make for longer delays&quot;&lt;/strong&gt;. This type of duplication is very easy to detect and handle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interdeveloper Duplication&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since this is the hardest of all type of duplications to detect, which makes us think that it will require utmost care to avoid or to detect. But for this also there is a simple practice by following it we can easily avoid it and even it persist then will be detected at an early stage. &lt;strong&gt;Active communication among developers &lt;/strong&gt;that&#39;s the only thing which can stop it, and this can be achieved by setting up discussion forms, newsgroups to exchange ideas and code reviews. All we should try to foster an environment where it&#39;s easy to find and reuse existing implementations rather building again from scratch.&lt;/p&gt;
&lt;p&gt;I hope you learned what I tried to teach and try to adapt at least some of them in your daily routine. That&#39;s all, &lt;strong&gt;happy hacking!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Nov 2015 15:15:16 +0530</pubDate>
        <link>http://phoenixx.me/2015/11/10/dont-repeat-yourself.html</link>
        <guid isPermaLink="true">http://phoenixx.me/2015/11/10/dont-repeat-yourself.html</guid>
        
        
      </item>
    
      <item>
        <title>Red - Green - Commit - Refactor - Commit</title>
        <description>&lt;p&gt;If you have ever done any test driven development(TDD), then you must be familiar with the title, to others this signifies an infinite development cycle which consists of following steps :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Red : Write a very small test code for the problem. How small?  , well it all depends on the context, but try to keep minimum. After writing this test code the build of project should fail. Also one thing worth observing is that this test code should be as independent as possible to the previous tests.&lt;/li&gt;
&lt;li&gt;Green: Now write code just to pass that test. The implementation should be as minimal as possible, or as dumb as possible.&lt;/li&gt;
&lt;li&gt;Commit : Commit the changes made to the project. The commit should not contain any code with which build is failing.&lt;/li&gt;
&lt;li&gt;Refactor: After having enough baby steps to understand problem&#39;s behaviour, if generalisation of problem is possible then this step comes in play and all the baby steps are replaced by that general formula. Note that tests should note be changed at all.&lt;/li&gt;
&lt;li&gt;Commit : Again commit the final changes.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The philosophy behind this kind of development is that even complex problems can be solved easily if you approach them in the dumbest way.&lt;/p&gt;
&lt;p&gt;Finally, the commits should be considered as important as code , since they help is maintaining discipline throughout the project. A series of good commits should look like story telling , thus decreases code maintenance time. And the most crucial yet ignored part of good commits is that they help you in bisecting and cherry-picking features from the project. Thus fine grain commits must be part of any project.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Nov 2015 14:58:04 +0530</pubDate>
        <link>http://phoenixx.me/2015/11/09/red-green-commit-refactor-commit.html</link>
        <guid isPermaLink="true">http://phoenixx.me/2015/11/09/red-green-commit-refactor-commit.html</guid>
        
        
      </item>
    
  </channel>
</rss>
